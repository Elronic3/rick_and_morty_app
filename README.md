# Rick and Morty Character Explorer

Додаток для перегляду інформації про персонажів та епізоди всесвіту "Рік і Морті".

## Функціональність

* **Список персонажів:** Відображення списку персонажів з пагінацією (infinite scroll). При прокручуванні вниз автоматично підвантажуються нові сторінки.
* **Пошук:** Фільтрування персонажів на ім'я із захистом від частих запитів (debounce).
* **Детальна інформація:** Перегляд подробиць про персонажа: статус, вид, тип, локація та список епізодів.
* **Епізоди:** Обробка посилань на епізоди з API. При натисканні на епізод відкривається екран з інформацією про серію (назва, код, дата виходу) та списком персонажів, що брали участь у ній.
* **Обробка станів:** Відображення завантаження, помилок мережі та порожніх результатів пошуку.

## Технологічний стек

* **Flutter / Dart**
* **http:** Єдина зовнішня залежність для виконання запитів REST API.
* **State Management:** Стандартні засоби Flutter. Сторонні бібліотеки (Provider, Bloc) не використовувалися.
* **Архітектура:** Поділ на Screens, Services, Models, Widgets.

## Структура проекту

```text
lib/
    /models/         # Моделі даних
    /services/       # Логіка роботи з мережею та API
    /screens/        # Екрани програми (UI)
    /widgets/        # Віджети, що перевикористовуються.
    /main.dart       # Точка входу
```

## Особливості

* **Оптимізація API запитів:** Замість виконання N запитів кожного епізоду чи персонажа, зроблено логіку групового завантаження. ID витягуються з посилань, і робиться один запит виду api/episode/1,2,3.
* **Кешування зображень:** Використовується стандартний NetworkImage, який забезпечує базове кешування в оперативній пам'яті в рамках сесії.

## Робота з API та оптимізація запитів

В качестве источника данных используется [Rick and Morty API](https://rickandmortyapi.com/). Вся сетевая логика в классе `ApiService`.
**Проблема:** API повертає пов'язані сутності (наприклад, список епізодів у персонажа) у вигляді масиву посилань:`["https://.../episode/10", "https://.../episode/28"]`.
Робити окремий HTTP-запит на кожне посилання неефективно (довго навантажує мережу).
**Рішення:**
Було реалізовано метод `_getMultipleByIds`. Він працює наступним чином:
1. Приймає список URL-адрес.
2. Парсить їх та витягує ID (останній сегмент шляху).
3. Формує один запит до API, використовуючи синтаксис множинного вибору (наприклад: `.../episode/10,28`).
4. Це дозволяє отримати інформацію про всі епізоди персонажа (або всіх персонажів епізоду) за один HTTP-дзвінок.

Також реалізована пагінація: `ApiService` приймає номер сторінки, а контролер списку (`ScrollController`) відстежує позицію скролла і запитує наступну сторінку при наближенні до кінця списку.

## Навігація між екранами
Навігація реалізована з використанням стандартного `Navigator` та `MaterialPageRoute`. Дані передаються через конструктори віджетів.

1. **HomeScreen:** Відображає список. При кліку на картку створюється екран CharacterDetailScreen, в який передається об'єкт Character.
2. **CharacterDetailScreen:** При ініціалізації асинхронно завантажує список епізодів, використовуючи надіслані URL з об'єкта персонажа. При натисканні на епізод відбувається перехід на `EpisodeDetailScreen` з передачею об'єкту `Episode`.
3. **EpisodeDetailScreen:** Аналогічно завантажує список персонажів для конкретного епізоду.
* Кнопка "Back" у AppBar та управління пристроєм працює належним чином та зберігає стан попередніх екранів у стеку.
